---
# tasks file for docker-jfrog-xray

- name: create the docker_compose folder
  become: yes
  ansible.builtin.file:
    path: "{{ docker_jfrog_xray_docker_compose_folder }}/certs"
    state: directory
    mode: 0700
    recurse: yes
    owner: service
    group: service

- name: download and extract the docker-compose package
  ansible.builtin.unarchive:
    src: "https://releases.jfrog.io/artifactory/jfrog-xray/xray-compose/{{ docker_jfrog_xray_version }}/jfrog-xray-{{ docker_jfrog_xray_version }}-compose.tar.gz"
    dest: "/tmp"
    remote_src: yes

- name: put the package files in the right folder
  ansible.builtin.copy:
    src: "/tmp/jfrog-xray-{{ docker_jfrog_xray_version }}-compose/"
    dest: "{{ docker_jfrog_xray_docker_compose_folder }}/"
    remote_src: yes

- name: copy the docker-compose files
  ansible.builtin.copy:
    src: "{{ docker_jfrog_xray_docker_compose_folder }}/{{ item }}"
    dest: "{{ docker_jfrog_xray_docker_compose_folder }}/"
    remote_src: yes
  loop:
    - templates/docker-compose.yaml
    - templates/docker-compose-postgres.yaml
    - templates/docker-compose-rabbitmq.yaml

- name: get docker-compose.yaml contents
  ansible.builtin.slurp:
    src: "{{ docker_jfrog_xray_docker_compose_folder }}/docker-compose.yaml"
  register: docker_jfrog_xray_slurp_docker_compose

- name: convert the slurped docker-compose to yaml
  ansible.builtin.set_fact:
    docker_jfrog_xray_docker_compose_yaml: "{{ docker_jfrog_xray_slurp_docker_compose['content'] | b64decode | from_yaml }}"

- name: remove the mongodb service
  ansible.builtin.set_fact:
    docker_jfrog_xray_docker_compose_clean_yaml:
      version: "{{ docker_jfrog_xray_docker_compose_yaml['version'] }}"
      services: "{{ {} | combine({item.key: item.value})}}"
  when: "{{ item.key not in ['mongodb'] }}"
  with_dict: "{{ docker_jfrog_xray_docker_compose_yaml['services'] }}"

- name: write the docker-compose.yaml back out
  ansible.builtin.copy:
    content: "{{ docker_jfrog_xray_docker_compose_clean_yaml | to_nice_yaml }}"
    dest: "{{ docker_jfrog_xray_docker_compose_folder }}/docker-compose.yaml"

- name: get the router container name
  ansible.builtin.set_fact:
    docker_jfrog_xray_router_container_name: "{{ docker_jfrog_xray_docker_compose_clean_yaml | regex_findall('container_name: (.+)') | first }}"

- name: ensure the container name is for router
  ansible.builtin.assert:
    that:
      - "'router' in docker_jfrog_xray_router_container_name"
    fail_msg: "The first service in the docker-compose.yml file is assumed to be for the router, but it doesn't appear so. Either the ordering changed or router is no longer in the container name."
    success_msg: "The first service in the docker-compose.yml file is for the router."

- name: remove lines with __REPLACE
  # At the time of this writing, the only one should be __REPLACE_POSTGRES_PASSWORD__ in docker-compose-postgresql.yaml
  ansible.builtin.lineinfile:
    path: "{{ docker_jfrog_xray_docker_compose_folder }}/{{ item }}"
    regexp: '.*__REPLACE.*'
    state: absent
  loop:
    - docker-compose.yaml
    - docker-compose-postgres.yaml
    - docker-compose-rabbitmq.yaml

- name: replace ROOT_DATA_DIR in .env
  ansible.builtin.lineinfile:
    path: "{{ docker_jfrog_xray_docker_compose_folder }}/.env"
    regexp: 'ROOT_DATA_DIR=.*'
    line: "ROOT_DATA_DIR={{ docker_jfrog_xray_data_dir }}"

- name: replace HOST_ID in .env
  ansible.builtin.lineinfile:
    path: "{{ docker_jfrog_xray_docker_compose_folder }}/.env"
    regexp: 'HOST_ID=.*'
    line: "HOST_ID={{ inventory_hostname }}"

- name: replace JF_THIRD_PARTY_BIND_IP in .env
  ansible.builtin.lineinfile:
    path: "{{ docker_jfrog_xray_docker_compose_folder }}/.env"
    regexp: 'JF_THIRD_PARTY_BIND_IP=.*'
    line: "JF_THIRD_PARTY_BIND_IP={{ ansible_default_ipv4.address }}"

- name: add JF_SHARED_JFROGURL in .env
  ansible.builtin.lineinfile:
    path: "{{ docker_jfrog_xray_docker_compose_folder }}/.env"
    line: "JF_SHARED_JFROGURL={{ docker_jfrog_xray_shared_jfrog_url }}"
    insertafter: EOF

- name: add JF_SHARED_SECURITY_JOINKEY in .env
  ansible.builtin.lineinfile:
    path: "{{ docker_jfrog_xray_docker_compose_folder }}/.env"
    line: "JF_SHARED_SECURITY_JOINKEY={{ docker_jfrog_xray_shared_security_joinkey }}"
    insertafter: EOF

- name: add JF_SHARED_NODE_IP in .env
  ansible.builtin.lineinfile:
    path: "{{ docker_jfrog_xray_docker_compose_folder }}/.env"
    line: "JF_SHARED_NODE_IP={{ ansible_default_ipv4.address }}"
    insertafter: EOF

- name: add POSTGRES_PASSWORD in .env
  ansible.builtin.lineinfile:
    path: "{{ docker_jfrog_xray_docker_compose_folder }}/.env"
    line: "POSTGRES_PASSWORD={{ docker_jfrog_xray_postgres_password }}"
    insertafter: EOF

- name: get .env contents
  ansible.builtin.slurp:
    src: "{{ docker_jfrog_xray_docker_compose_folder }}/.env"
  register: docker_jfrog_xray_slurp_env

- name: get XRAY_USER from .env
  ansible.builtin.set_fact:
    docker_jfrog_xray_user: "{{ docker_jfrog_xray_slurp_env['content'] | b64decode | regex_findall('XRAY_USER=(.+)') | first }}"

- name: copy certificates to trust locally
  become: yes
  ansible.builtin.copy:
    src: "{{ item.path }}"
    dest: "{{ docker_jfrog_xray_docker_compose_folder }}/certs"
    remote_src: "{{ item.remote_src }}"
    mode: 0744
    owner: "{{ docker_jfrog_xray_user }}"
    group: "{{ docker_jfrog_xray_user }}"
  loop: "{{ docker_jfrog_xray_certs_to_trust }}"
  when: docker_jfrog_xray_certs_to_trust is defined

- name: create the application folders for xray
  become: yes
  ansible.builtin.file:
    path: "{{ docker_jfrog_xray_data_dir }}/{{ item }}"
    state: directory
    mode: 0700
    owner: "{{ docker_jfrog_xray_user }}"
    group: "{{ docker_jfrog_xray_user }}"
    recurse: yes
  with_items:
    - var/data
    - var/etc

- name: create the application folders for third-party
  become: yes
  ansible.builtin.file:
    path: "{{ docker_jfrog_xray_data_dir }}/{{ item }}"
    state: directory
    mode: 0700
    owner: "999"
    group: "999"
    recurse: yes
  with_items:
    - app/third-party/rabbitmq

- name: pull docker postgres
  ansible.builtin.shell:
    cmd: docker-compose pull --file docker-compose-postgres.yaml --project-name xray-postgres
    chdir: "{{ docker_jfrog_xray_docker_compose_folder }}"
    executable: /bin/bash

- name: pull docker rabbitmq
  ansible.builtin.shell:
    cmd: docker-compose pull --file docker-compose-rabbitmq.yaml --project-name xray-rabbitmq
    chdir: "{{ docker_jfrog_xray_docker_compose_folder }}"
    executable: /bin/bash

- name: pull docker xray
  ansible.builtin.shell:
    cmd: docker-compose pull --project-name xray
    chdir: "{{ docker_jfrog_xray_docker_compose_folder }}"
    executable: /bin/bash

- name: run the postgres export and import
  include_tasks: postgresql_migrate.yml
  when: docker_jfrog_xray_postgresql_migrate is defined and docker_jfrog_xray_postgresql_migrate | bool

- name: bring up docker postgres
  ansible.builtin.shell:
    cmd: docker-compose up --detach --file docker-compose-postgres.yaml --project-name xray-postgres
    chdir: "{{ docker_jfrog_xray_docker_compose_folder }}"
    executable: /bin/bash

- name: wait 15 seconds to ensure the container is up
  ansible.builtin.pause:
    seconds: 15

- name: bring up docker rabbitmq
  ansible.builtin.shell:
    cmd: docker-compose up --detach --file docker-compose-rabbitmq.yaml --project-name xray-rabbitmq
    chdir: "{{ docker_jfrog_xray_docker_compose_folder }}"
    executable: /bin/bash

- name: wait 15 seconds to ensure the container is up
  ansible.builtin.pause:
    seconds: 15

- name: bring up docker xray
  ansible.builtin.shell:
    cmd: docker-compose up --detach --project-name xray
    chdir: "{{ docker_jfrog_xray_docker_compose_folder }}"
    executable: /bin/bash

# This must be done immediately after the xray containers are started so the certs are present in time before xray tries to communicate with Artifactory.
- name: copy certificates to trust into the container
  ansible.builtin.shell:
    # https://www.jfrog.com/confluence/display/JFROG/Managing+TLS+Certificates#ManagingTLSCertificates-TrustingaSelf-SignedCertificateoraNewCA
    # Adding the cert to the application's keystore isn't trivial (i.e. mucking with the JVM, especially if java isn't on the path).
    # Using "{{ docker_jfrog_xray_data_dir }}/var/etc/security/keys/trusted" didn't work for whatever reason.
    # Dumping the certs in /etc/ssl/certs seems to work though. A mounted volume would be better, but there's already stuff in this folder, and
    # I don't want to modify the docker-compose.yml file to add the volume either. A docker copy is the best solution.
    cmd: "docker cp {{ item }} {{ docker_jfrog_xray_router_container_name }}:/etc/ssl/certs/"
    executable: /bin/bash
  with_fileglob:
    - "{{ docker_jfrog_xray_docker_compose_folder }}/certs/*"
  when: docker_jfrog_xray_certs_to_trust is defined